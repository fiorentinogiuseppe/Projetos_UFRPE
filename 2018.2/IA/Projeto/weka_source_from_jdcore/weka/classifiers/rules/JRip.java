package weka.classifiers.rules;

import java.io.PrintStream;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;
import weka.classifiers.Classifier;
import weka.core.AdditionalMeasureProducer;
import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.Capabilities.Capability;
import weka.core.Copyable;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.filters.Filter;
import weka.filters.supervised.attribute.ClassOrder;


















































































































public class JRip
  extends Classifier
  implements AdditionalMeasureProducer, WeightedInstancesHandler, TechnicalInformationHandler
{
  static final long serialVersionUID = -6589312996832147161L;
  private static double MAX_DL_SURPLUS = 64.0D;
  
  private Attribute m_Class;
  private FastVector m_Ruleset;
  private FastVector m_Distributions;
  private int m_Optimizations;
  private Random m_Random;
  private double m_Total;
  private long m_Seed;
  
  public JRip()
  {
    m_Optimizations = 2;
    

    m_Random = null;
    

    m_Total = 0.0D;
    

    m_Seed = 1L;
    

    m_Folds = 3;
    

    m_MinNo = 2.0D;
    

    m_Debug = false;
    

    m_CheckErr = true;
    

    m_UsePruning = true;
    

    m_Filter = null;
  }
  







  public String globalInfo()
  {
    return "This class implements a propositional rule learner, Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was proposed by William W. Cohen as an optimized version of IREP. \n\nThe algorithm is briefly described as follows: \n\nInitialize RS = {}, and for each class from the less prevalent one to the more frequent one, DO: \n\n1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and examples is 64 bits greater than the smallest DL met so far, or there are no positive examples, or the error rate >= 50%. \n\n1.1. Grow phase:\nGrow one rule by greedily adding antecedents (or conditions) to the rule until the rule is perfect (i.e. 100% accurate).  The procedure tries every possible value of each attribute and selects the condition with highest information gain: p(log(p/t)-log(P/T)).\n\n1.2. Prune phase:\nIncrementally prune each rule and allow the pruning of any final sequences of the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n2. Optimization stage:\n after generating the initial ruleset {Ri}, generate and prune two variants of each rule Ri from randomized data using procedure 1.1 and 1.2. But one variant is generated from an empty rule while the other is generated by greedily adding antecedents to the original rule. Moreover, the pruning metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each variant and the original rule is computed.  The variant with the minimal DL is selected as the final representative of Ri in the ruleset.After all the rules in {Ri} have been examined and if there are still residual positives, more rules are generated based on the residual positives using Building Stage again. \n3. Delete the rules from the ruleset that would increase the DL of the whole ruleset if it were in it. and add resultant ruleset to RS. \nENDDO\n\nNote that there seem to be 2 bugs in the original ripper program that would affect the ruleset size and accuracy slightly.  This implementation avoids these bugs and thus is a little bit different from Cohen's original implementation. Even after fixing the bugs, since the order of classes with the same frequency is not defined in ripper, there still seems to be some trivial difference between this implementation and the original ripper, especially for audiology data in UCI repository, where there are lots of classes of few instances.\n\nDetails please see:\n\n" + getTechnicalInformation().toString() + "\n\n" + "PS.  We have compared this implementation with the original ripper " + "implementation in aspects of accuracy, ruleset size and running time " + "on both artificial data \"ab+bcd+defg\" and UCI datasets.  In all these " + "aspects it seems to be quite comparable to the original ripper " + "implementation.  However, we didn't consider memory consumption " + "optimization in this implementation.\n\n";
  }
  







  private int m_Folds;
  






  private double m_MinNo;
  






  private boolean m_Debug;
  






  private boolean m_CheckErr;
  






  private boolean m_UsePruning;
  





  private Filter m_Filter;
  





  private FastVector m_RulesetStats;
  





  public TechnicalInformation getTechnicalInformation()
  {
    TechnicalInformation result = new TechnicalInformation(TechnicalInformation.Type.INPROCEEDINGS);
    result.setValue(TechnicalInformation.Field.AUTHOR, "William W. Cohen");
    result.setValue(TechnicalInformation.Field.TITLE, "Fast Effective Rule Induction");
    result.setValue(TechnicalInformation.Field.BOOKTITLE, "Twelfth International Conference on Machine Learning");
    result.setValue(TechnicalInformation.Field.YEAR, "1995");
    result.setValue(TechnicalInformation.Field.PAGES, "115-123");
    result.setValue(TechnicalInformation.Field.PUBLISHER, "Morgan Kaufmann");
    
    return result;
  }
  





























  public Enumeration listOptions()
  {
    Vector newVector = new Vector(3);
    newVector.addElement(new Option("\tSet number of folds for REP\n\tOne fold is used as pruning set.\n\t(default 3)", "F", 1, "-F <number of folds>"));
    

    newVector.addElement(new Option("\tSet the minimal weights of instances\n\twithin a split.\n\t(default 2.0)", "N", 1, "-N <min. weights>"));
    

    newVector.addElement(new Option("\tSet the number of runs of\n\toptimizations. (Default: 2)", "O", 1, "-O <number of runs>"));
    


    newVector.addElement(new Option("\tSet whether turn on the\n\tdebug mode (Default: false)", "D", 0, "-D"));
    


    newVector.addElement(new Option("\tThe seed of randomization\n\t(Default: 1)", "S", 1, "-S <seed>"));
    


    newVector.addElement(new Option("\tWhether NOT check the error rate>=0.5\n\tin stopping criteria \t(default: check)", "E", 0, "-E"));
    



    newVector.addElement(new Option("\tWhether NOT use pruning\n\t(default: use pruning)", "P", 0, "-P"));
    

    return newVector.elements();
  }
  







































  public void setOptions(String[] options)
    throws Exception
  {
    String numFoldsString = Utils.getOption('F', options);
    if (numFoldsString.length() != 0) {
      m_Folds = Integer.parseInt(numFoldsString);
    } else {
      m_Folds = 3;
    }
    String minNoString = Utils.getOption('N', options);
    if (minNoString.length() != 0) {
      m_MinNo = Double.parseDouble(minNoString);
    } else {
      m_MinNo = 2.0D;
    }
    String seedString = Utils.getOption('S', options);
    if (seedString.length() != 0) {
      m_Seed = Long.parseLong(seedString);
    } else {
      m_Seed = 1L;
    }
    String runString = Utils.getOption('O', options);
    if (runString.length() != 0) {
      m_Optimizations = Integer.parseInt(runString);
    } else {
      m_Optimizations = 2;
    }
    m_Debug = Utils.getFlag('D', options);
    m_CheckErr = (!Utils.getFlag('E', options));
    m_UsePruning = (!Utils.getFlag('P', options));
  }
  





  public String[] getOptions()
  {
    String[] options = new String[11];
    int current = 0;
    options[(current++)] = "-F";options[(current++)] = ("" + m_Folds);
    options[(current++)] = "-N";options[(current++)] = ("" + m_MinNo);
    options[(current++)] = "-O";options[(current++)] = ("" + m_Optimizations);
    options[(current++)] = "-S";options[(current++)] = ("" + m_Seed);
    
    if (m_Debug) {
      options[(current++)] = "-D";
    }
    if (!m_CheckErr) {
      options[(current++)] = "-E";
    }
    if (!m_UsePruning) {
      options[(current++)] = "-P";
    }
    while (current < options.length) {
      options[(current++)] = "";
    }
    return options;
  }
  



  public Enumeration enumerateMeasures()
  {
    Vector newVector = new Vector(1);
    newVector.addElement("measureNumRules");
    return newVector.elements();
  }
  





  public double getMeasure(String additionalMeasureName)
  {
    if (additionalMeasureName.compareToIgnoreCase("measureNumRules") == 0) {
      return m_Ruleset.size();
    }
    throw new IllegalArgumentException(additionalMeasureName + " not supported (RIPPER)");
  }
  




  public String foldsTipText()
  {
    return "Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.";
  }
  





  public void setFolds(int fold)
  {
    m_Folds = fold;
  }
  




  public int getFolds()
  {
    return m_Folds;
  }
  




  public String minNoTipText()
  {
    return "The minimum total weight of the instances in a rule.";
  }
  




  public void setMinNo(double m)
  {
    m_MinNo = m;
  }
  




  public double getMinNo()
  {
    return m_MinNo;
  }
  




  public String seedTipText()
  {
    return "The seed used for randomizing the data.";
  }
  




  public void setSeed(long s)
  {
    m_Seed = s;
  }
  




  public long getSeed()
  {
    return m_Seed;
  }
  




  public String optimizationsTipText()
  {
    return "The number of optimization runs.";
  }
  




  public void setOptimizations(int run)
  {
    m_Optimizations = run;
  }
  




  public int getOptimizations()
  {
    return m_Optimizations;
  }
  




  public String debugTipText()
  {
    return "Whether debug information is output to the console.";
  }
  




  public void setDebug(boolean d)
  {
    m_Debug = d;
  }
  




  public boolean getDebug()
  {
    return m_Debug;
  }
  




  public String checkErrorRateTipText()
  {
    return "Whether check for error rate >= 1/2 is included in stopping criterion.";
  }
  





  public void setCheckErrorRate(boolean d)
  {
    m_CheckErr = d;
  }
  




  public boolean getCheckErrorRate()
  {
    return m_CheckErr;
  }
  




  public String usePruningTipText()
  {
    return "Whether pruning is performed.";
  }
  




  public void setUsePruning(boolean d)
  {
    m_UsePruning = d;
  }
  




  public boolean getUsePruning()
  {
    return m_UsePruning;
  }
  



  public FastVector getRuleset()
  {
    return m_Ruleset;
  }
  




  public RuleStats getRuleStats(int pos)
  {
    return (RuleStats)m_RulesetStats.elementAt(pos);
  }
  



  public abstract class Antd
    implements WeightedInstancesHandler, Copyable, Serializable, RevisionHandler
  {
    private static final long serialVersionUID = -8929754772994154334L;
    


    protected Attribute att;
    


    protected double value;
    


    protected double maxInfoGain;
    


    protected double accuRate;
    


    protected double cover;
    

    protected double accu;
    


    public Antd(Attribute a)
    {
      att = a;
      value = NaN.0D;
      maxInfoGain = 0.0D;
      accuRate = NaN.0D;
      cover = NaN.0D;
      accu = NaN.0D;
    }
    


    public abstract Instances[] splitData(Instances paramInstances, double paramDouble1, double paramDouble2);
    


    public abstract boolean covers(Instance paramInstance);
    

    public abstract String toString();
    

    public abstract Object copy();
    
    public Attribute getAttr() { return att; }
    public double getAttrValue() { return value; }
    public double getMaxInfoGain() { return maxInfoGain; }
    public double getAccuRate() { return accuRate; }
    public double getAccu() { return accu; }
    public double getCover() { return cover; }
    




    public String getRevision()
    {
      return RevisionUtils.extract("$Revision: 8119 $");
    }
  }
  



  public class NumericAntd
    extends JRip.Antd
  {
    static final long serialVersionUID = 5699457269983735442L;
    


    private double splitPoint;
    


    public NumericAntd(Attribute a)
    {
      super(a);
      splitPoint = NaN.0D;
    }
    




    public double getSplitPoint()
    {
      return splitPoint;
    }
    




    public Object copy()
    {
      NumericAntd na = new NumericAntd(JRip.this, getAttr());
      value = value;
      splitPoint = splitPoint;
      return na;
    }
    











    public Instances[] splitData(Instances insts, double defAcRt, double cl)
    {
      Instances data = insts;
      int total = data.numInstances();
      

      int split = 1;
      int prev = 0;
      int finalSplit = split;
      maxInfoGain = 0.0D;
      value = 0.0D;
      
      double fstCover = 0.0D;double sndCover = 0.0D;double fstAccu = 0.0D;double sndAccu = 0.0D;
      
      data.sort(att);
      
      for (int x = 0; x < data.numInstances(); x++) {
        Instance inst = data.instance(x);
        if (inst.isMissing(att)) {
          total = x;
          break;
        }
        
        sndCover += inst.weight();
        if (Utils.eq(inst.classValue(), cl)) {
          sndAccu += inst.weight();
        }
      }
      if (total == 0) return null;
      splitPoint = data.instance(total - 1).value(att);
      for (; 
          split <= total; split++) {
        if ((split == total) || (data.instance(split).value(att) > data.instance(prev).value(att)))
        {


          for (int y = prev; y < split; y++) {
            Instance inst = data.instance(y);
            fstCover += inst.weight();
            if (Utils.eq(data.instance(y).classValue(), cl)) {
              fstAccu += inst.weight();
            }
          }
          
          double fstAccuRate = (fstAccu + 1.0D) / (fstCover + 1.0D);
          double sndAccuRate = (sndAccu + 1.0D) / (sndCover + 1.0D);
          





          double fstInfoGain = fstAccu * (Utils.log2(fstAccuRate) - Utils.log2(defAcRt));
          



          double sndInfoGain = sndAccu * (Utils.log2(sndAccuRate) - Utils.log2(defAcRt));
          double coverage;
          boolean isFirst;
          double infoGain;
          double accRate;
          double accurate; double coverage; if (fstInfoGain > sndInfoGain) {
            boolean isFirst = true;
            double infoGain = fstInfoGain;
            double accRate = fstAccuRate;
            double accurate = fstAccu;
            coverage = fstCover;
          }
          else {
            isFirst = false;
            infoGain = sndInfoGain;
            accRate = sndAccuRate;
            accurate = sndAccu;
            coverage = sndCover;
          }
          

          if (infoGain > maxInfoGain) {
            splitPoint = data.instance(prev).value(att);
            value = (isFirst ? 0.0D : 1.0D);
            accuRate = accRate;
            accu = accurate;
            cover = coverage;
            maxInfoGain = infoGain;
            finalSplit = isFirst ? split : prev;
          }
          
          for (int y = prev; y < split; y++) {
            Instance inst = data.instance(y);
            sndCover -= inst.weight();
            if (Utils.eq(data.instance(y).classValue(), cl)) {
              sndAccu -= inst.weight();
            }
          }
          prev = split;
        }
      }
      

      Instances[] splitData = new Instances[2];
      splitData[0] = new Instances(data, 0, finalSplit);
      splitData[1] = new Instances(data, finalSplit, total - finalSplit);
      
      return splitData;
    }
    






    public boolean covers(Instance inst)
    {
      boolean isCover = true;
      if (!inst.isMissing(att)) {
        if ((int)value == 0) {
          if (inst.value(att) > splitPoint) {
            isCover = false;
          }
        } else if (inst.value(att) < splitPoint) {
          isCover = false;
        }
      } else {
        isCover = false;
      }
      return isCover;
    }
    




    public String toString()
    {
      String symbol = (int)value == 0 ? " <= " : " >= ";
      return att.name() + symbol + Utils.doubleToString(splitPoint, 6);
    }
    




    public String getRevision()
    {
      return RevisionUtils.extract("$Revision: 8119 $");
    }
  }
  



  public class NominalAntd
    extends JRip.Antd
  {
    static final long serialVersionUID = -9102297038837585135L;
    


    private double[] accurate;
    

    private double[] coverage;
    


    public NominalAntd(Attribute a)
    {
      super(a);
      int bag = att.numValues();
      accurate = new double[bag];
      coverage = new double[bag];
    }
    




    public Object copy()
    {
      JRip.Antd antec = new NominalAntd(JRip.this, getAttr());
      value = value;
      return antec;
    }
    











    public Instances[] splitData(Instances data, double defAcRt, double cl)
    {
      int bag = att.numValues();
      Instances[] splitData = new Instances[bag];
      
      for (int x = 0; x < bag; x++) {
        splitData[x] = new Instances(data, data.numInstances());
        accurate[x] = 0.0D;
        coverage[x] = 0.0D;
      }
      
      for (int x = 0; x < data.numInstances(); x++) {
        Instance inst = data.instance(x);
        if (!inst.isMissing(att)) {
          int v = (int)inst.value(att);
          splitData[v].add(inst);
          coverage[v] += inst.weight();
          if ((int)inst.classValue() == (int)cl) {
            accurate[v] += inst.weight();
          }
        }
      }
      for (int x = 0; x < bag; x++) {
        double t = coverage[x] + 1.0D;
        double p = accurate[x] + 1.0D;
        double infoGain = accurate[x] * (Utils.log2(p / t) - Utils.log2(defAcRt));
        



        if (infoGain > maxInfoGain) {
          maxInfoGain = infoGain;
          cover = coverage[x];
          accu = accurate[x];
          accuRate = (p / t);
          value = x;
        }
      }
      
      return splitData;
    }
    






    public boolean covers(Instance inst)
    {
      boolean isCover = false;
      if ((!inst.isMissing(att)) && 
        ((int)inst.value(att) == (int)value)) {
        isCover = true;
      }
      return isCover;
    }
    




    public String toString()
    {
      return att.name() + " = " + att.value((int)value);
    }
    




    public String getRevision()
    {
      return RevisionUtils.extract("$Revision: 8119 $");
    }
  }
  







  public class RipperRule
    extends Rule
  {
    static final long serialVersionUID = -2410020717305262952L;
    





    private double m_Consequent = -1.0D;
    

    protected FastVector m_Antds = null;
    
    public RipperRule()
    {
      m_Antds = new FastVector();
    }
    




    public void setConsequent(double cl)
    {
      m_Consequent = cl;
    }
    




    public double getConsequent()
    {
      return m_Consequent;
    }
    




    public Object copy()
    {
      RipperRule copy = new RipperRule(JRip.this);
      copy.setConsequent(getConsequent());
      m_Antds = ((FastVector)m_Antds.copyElements());
      return copy;
    }
    






    public boolean covers(Instance datum)
    {
      boolean isCover = true;
      
      for (int i = 0; i < m_Antds.size(); i++) {
        JRip.Antd antd = (JRip.Antd)m_Antds.elementAt(i);
        if (!antd.covers(datum)) {
          isCover = false;
          break;
        }
      }
      
      return isCover;
    }
    




    public boolean hasAntds()
    {
      if (m_Antds == null) {
        return false;
      }
      return m_Antds.size() > 0;
    }
    




    public FastVector getAntds()
    {
      return m_Antds;
    }
    



    public double size()
    {
      return m_Antds.size();
    }
    






    private double computeDefAccu(Instances data)
    {
      double defAccu = 0.0D;
      for (int i = 0; i < data.numInstances(); i++) {
        Instance inst = data.instance(i);
        if ((int)inst.classValue() == (int)m_Consequent)
          defAccu += inst.weight();
      }
      return defAccu;
    }
    





    public void grow(Instances data)
      throws Exception
    {
      if (m_Consequent == -1.0D) {
        throw new Exception(" Consequent not set yet.");
      }
      Instances growData = data;
      double sumOfWeights = growData.sumOfWeights();
      if (!Utils.gr(sumOfWeights, 0.0D)) {
        return;
      }
      
      double defAccu = computeDefAccu(growData);
      double defAcRt = (defAccu + 1.0D) / (sumOfWeights + 1.0D);
      

      boolean[] used = new boolean[growData.numAttributes()];
      for (int k = 0; k < used.length; k++)
        used[k] = false;
      int numUnused = used.length;
      

      for (int j = 0; j < m_Antds.size(); j++) {
        JRip.Antd antdj = (JRip.Antd)m_Antds.elementAt(j);
        if (!antdj.getAttr().isNumeric()) {
          used[antdj.getAttr().index()] = true;
          numUnused--;
        }
      }
      



      while ((Utils.gr(growData.numInstances(), 0.0D)) && (numUnused > 0) && (Utils.sm(defAcRt, 1.0D)))
      {







        double maxInfoGain = 0.0D;
        

        JRip.Antd oneAntd = null;
        Instances coverData = null;
        Enumeration enumAttr = growData.enumerateAttributes();
        

        while (enumAttr.hasMoreElements()) {
          Attribute att = (Attribute)enumAttr.nextElement();
          
          if (m_Debug) {
            System.err.println("\nOne condition: size = " + growData.sumOfWeights());
          }
          
          JRip.Antd antd = null;
          if (att.isNumeric()) {
            antd = new JRip.NumericAntd(JRip.this, att);
          } else {
            antd = new JRip.NominalAntd(JRip.this, att);
          }
          if (used[att.index()] == 0)
          {


            Instances coveredData = computeInfoGain(growData, defAcRt, antd);
            
            if (coveredData != null) {
              double infoGain = antd.getMaxInfoGain();
              if (m_Debug) {
                System.err.println("Test of '" + antd.toString() + "': infoGain = " + infoGain + " | Accuracy = " + antd.getAccuRate() + "=" + antd.getAccu() + "/" + antd.getCover() + " def. accuracy: " + defAcRt);
              }
              





              if (infoGain > maxInfoGain) {
                oneAntd = antd;
                coverData = coveredData;
                maxInfoGain = infoGain;
              }
            }
          }
        }
        
        if ((oneAntd == null) || 
          (Utils.sm(oneAntd.getAccu(), m_MinNo))) {
          break;
        }
        if (!oneAntd.getAttr().isNumeric()) {
          used[oneAntd.getAttr().index()] = true;
          numUnused--;
        }
        
        m_Antds.addElement(oneAntd);
        growData = coverData;
        defAcRt = oneAntd.getAccuRate();
      }
    }
    










    private Instances computeInfoGain(Instances instances, double defAcRt, JRip.Antd antd)
    {
      Instances data = instances;
      


      Instances[] splitData = antd.splitData(data, defAcRt, m_Consequent);
      


      if (splitData != null)
        return splitData[((int)antd.getAttrValue())];
      return null;
    }
    








    public void prune(Instances pruneData, boolean useWhole)
    {
      Instances data = pruneData;
      
      double total = data.sumOfWeights();
      if (!Utils.gr(total, 0.0D)) {
        return;
      }
      
      double defAccu = computeDefAccu(data);
      
      if (m_Debug) {
        System.err.println("Pruning with " + defAccu + " positive data out of " + total + " instances");
      }
      

      int size = m_Antds.size();
      if (size == 0) { return;
      }
      double[] worthRt = new double[size];
      double[] coverage = new double[size];
      double[] worthValue = new double[size];
      for (int w = 0; w < size; w++) {
        double tmp134_133 = (worthValue[w] = 0.0D);coverage[w] = tmp134_133;worthRt[w] = tmp134_133;
      }
      

      double tn = 0.0D;
      for (int x = 0; x < size; x++) {
        JRip.Antd antd = (JRip.Antd)m_Antds.elementAt(x);
        Instances newData = data;
        data = new Instances(newData, 0);
        
        for (int y = 0; y < newData.numInstances(); y++) {
          Instance ins = newData.instance(y);
          
          if (antd.covers(ins)) {
            coverage[x] += ins.weight();
            data.add(ins);
            if ((int)ins.classValue() == (int)m_Consequent) {
              worthValue[x] += ins.weight();
            }
          } else if ((useWhole) && 
            ((int)ins.classValue() != (int)m_Consequent)) {
            tn += ins.weight();
          }
        }
        
        if (useWhole) {
          worthValue[x] += tn;
          worthValue[x] /= total;
        }
        else {
          worthRt[x] = ((worthValue[x] + 1.0D) / (coverage[x] + 2.0D));
        }
      }
      double maxValue = (defAccu + 1.0D) / (total + 2.0D);
      int maxIndex = -1;
      for (int i = 0; i < worthValue.length; i++) {
        if (m_Debug) {
          double denom = useWhole ? total : coverage[i];
          System.err.println(i + "(useAccuray? " + (!useWhole) + "): " + worthRt[i] + "=" + worthValue[i] + "/" + denom);
        }
        


        if (worthRt[i] > maxValue) {
          maxValue = worthRt[i];
          maxIndex = i;
        }
      }
      

      for (int z = size - 1; z > maxIndex; z--) {
        m_Antds.removeElementAt(z);
      }
    }
    




    public String toString(Attribute classAttr)
    {
      StringBuffer text = new StringBuffer();
      if (m_Antds.size() > 0) {
        for (int j = 0; j < m_Antds.size() - 1; j++)
          text.append("(" + ((JRip.Antd)m_Antds.elementAt(j)).toString() + ") and ");
        text.append("(" + ((JRip.Antd)m_Antds.lastElement()).toString() + ")");
      }
      text.append(" => " + classAttr.name() + "=" + classAttr.value((int)m_Consequent));
      

      return text.toString();
    }
    




    public String getRevision()
    {
      return RevisionUtils.extract("$Revision: 8119 $");
    }
  }
  




  public Capabilities getCapabilities()
  {
    Capabilities result = super.getCapabilities();
    result.disableAll();
    

    result.enable(Capabilities.Capability.NOMINAL_ATTRIBUTES);
    result.enable(Capabilities.Capability.NUMERIC_ATTRIBUTES);
    result.enable(Capabilities.Capability.DATE_ATTRIBUTES);
    result.enable(Capabilities.Capability.MISSING_VALUES);
    

    result.enable(Capabilities.Capability.NOMINAL_CLASS);
    result.enable(Capabilities.Capability.MISSING_CLASS_VALUES);
    

    result.setMinimumNumberInstances(m_Folds);
    
    return result;
  }
  







  public void buildClassifier(Instances instances)
    throws Exception
  {
    getCapabilities().testWithFail(instances);
    

    instances = new Instances(instances);
    instances.deleteWithMissingClass();
    
    m_Random = instances.getRandomNumberGenerator(m_Seed);
    m_Total = RuleStats.numAllConditions(instances);
    if (m_Debug) {
      System.err.println("Number of all possible conditions = " + m_Total);
    }
    Instances data = null;
    m_Filter = new ClassOrder();
    ((ClassOrder)m_Filter).setSeed(m_Random.nextInt());
    ((ClassOrder)m_Filter).setClassOrder(0);
    m_Filter.setInputFormat(instances);
    data = Filter.useFilter(instances, m_Filter);
    
    if (data == null) {
      throw new Exception(" Unable to randomize the class orders.");
    }
    m_Class = data.classAttribute();
    m_Ruleset = new FastVector();
    m_RulesetStats = new FastVector();
    m_Distributions = new FastVector();
    

    double[] orderedClasses = ((ClassOrder)m_Filter).getClassCounts();
    if (m_Debug) {
      System.err.println("Sorted classes:");
      for (int x = 0; x < m_Class.numValues(); x++) {
        System.err.println(x + ": " + m_Class.value(x) + " has " + orderedClasses[x] + " instances.");
      }
    }
    

    for (int y = 0; y < data.numClasses() - 1; y++)
    {
      double classIndex = y;
      if (m_Debug) {
        int ci = (int)classIndex;
        System.err.println("\n\nClass " + m_Class.value(ci) + "(" + ci + "): " + orderedClasses[y] + "instances\n" + "=====================================\n");
      }
      


      if (!Utils.eq(orderedClasses[y], 0.0D))
      {


        double all = 0.0D;
        for (int i = y; i < orderedClasses.length; i++)
          all += orderedClasses[i];
        double expFPRate = orderedClasses[y] / all;
        
        double classYWeights = 0.0D;double totalWeights = 0.0D;
        for (int j = 0; j < data.numInstances(); j++) {
          Instance datum = data.instance(j);
          totalWeights += datum.weight();
          if ((int)datum.classValue() == y) {
            classYWeights += datum.weight();
          }
        }
        


        if (classYWeights > 0.0D) {
          double defDL = RuleStats.dataDL(expFPRate, 0.0D, totalWeights, 0.0D, classYWeights);
          






          if ((Double.isNaN(defDL)) || (Double.isInfinite(defDL))) {
            throw new Exception("Should never happen: defDL NaN or infinite!");
          }
          if (m_Debug) {
            System.err.println("The default DL = " + defDL);
          }
          data = rulesetForOneClass(expFPRate, data, classIndex, defDL);
        }
      }
    }
    RipperRule defRule = new RipperRule();
    defRule.setConsequent(data.numClasses() - 1);
    m_Ruleset.addElement(defRule);
    
    RuleStats defRuleStat = new RuleStats();
    defRuleStat.setData(data);
    defRuleStat.setNumAllConds(m_Total);
    defRuleStat.addAndUpdate(defRule);
    m_RulesetStats.addElement(defRuleStat);
    
    for (int z = 0; z < m_RulesetStats.size(); z++) {
      RuleStats oneClass = (RuleStats)m_RulesetStats.elementAt(z);
      for (int xyz = 0; xyz < oneClass.getRulesetSize(); xyz++) {
        double[] classDist = oneClass.getDistributions(xyz);
        Utils.normalize(classDist);
        if (classDist != null) {
          m_Distributions.addElement(((ClassOrder)m_Filter).distributionsByOriginalIndex(classDist));
        }
      }
    }
    
    for (int i = 0; i < m_RulesetStats.size(); i++) {
      ((RuleStats)m_RulesetStats.elementAt(i)).cleanUp();
    }
  }
  




  public double[] distributionForInstance(Instance datum)
  {
    try
    {
      for (int i = 0; i < m_Ruleset.size(); i++) {
        RipperRule rule = (RipperRule)m_Ruleset.elementAt(i);
        if (rule.covers(datum))
          return (double[])m_Distributions.elementAt(i);
      }
    } catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
    }
    
    System.err.println("Should never happen!");
    return new double[datum.classAttribute().numValues()];
  }
  











  protected Instances rulesetForOneClass(double expFPRate, Instances data, double classIndex, double defDL)
    throws Exception
  {
    Instances newData = data;
    boolean stop = false;
    FastVector ruleset = new FastVector();
    
    double dl = defDL;double minDL = defDL;
    RuleStats rstats = null;
    


    boolean defHasPositive = true;
    boolean hasPositive = defHasPositive;
    

    if (m_Debug) {
      System.err.println("\n*** Building stage ***");
    }
    while ((!stop) && (hasPositive))
    {
      RipperRule oneRule;
      if (m_UsePruning)
      {





        newData = RuleStats.stratify(newData, m_Folds, m_Random);
        Instances[] part = RuleStats.partition(newData, m_Folds);
        Instances growData = part[0];
        Instances pruneData = part[1];
        


        RipperRule oneRule = new RipperRule();
        oneRule.setConsequent(classIndex);
        
        if (m_Debug)
          System.err.println("\nGrowing a rule ...");
        oneRule.grow(growData);
        if (m_Debug) {
          System.err.println("One rule found before pruning:" + oneRule.toString(m_Class));
        }
        
        if (m_Debug)
          System.err.println("\nPruning the rule ...");
        oneRule.prune(pruneData, false);
        if (m_Debug) {
          System.err.println("One rule found after pruning:" + oneRule.toString(m_Class));
        }
      }
      else {
        oneRule = new RipperRule();
        oneRule.setConsequent(classIndex);
        if (m_Debug)
          System.err.println("\nNo pruning: growing a rule ...");
        oneRule.grow(newData);
        if (m_Debug) {
          System.err.println("No pruning: one rule found:\n" + oneRule.toString(m_Class));
        }
      }
      

      if (rstats == null) {
        rstats = new RuleStats();
        rstats.setNumAllConds(m_Total);
        rstats.setData(newData);
      }
      
      rstats.addAndUpdate(oneRule);
      int last = rstats.getRuleset().size() - 1;
      dl += rstats.relativeDL(last, expFPRate, m_CheckErr);
      
      if ((Double.isNaN(dl)) || (Double.isInfinite(dl))) {
        throw new Exception("Should never happen: dl in building stage NaN or infinite!");
      }
      if (m_Debug) {
        System.err.println("Before optimization(" + last + "): the dl = " + dl + " | best: " + minDL);
      }
      
      if (dl < minDL) {
        minDL = dl;
      }
      double[] rst = rstats.getSimpleStats(last);
      if (m_Debug) {
        System.err.println("The rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
      }
      



      stop = checkStop(rst, minDL, dl);
      
      if (!stop) {
        ruleset.addElement(oneRule);
        newData = rstats.getFiltered(last)[1];
        hasPositive = Utils.gr(rst[5], 0.0D);
        if (m_Debug) {
          System.err.println("One rule added: has positive? " + hasPositive);
        }
      }
      else {
        if (m_Debug)
          System.err.println("Quit rule");
        rstats.removeLast();
      }
    }
    

    RuleStats finalRulesetStat = null;
    if (m_UsePruning) {
      for (int z = 0; z < m_Optimizations; z++) {
        if (m_Debug) {
          System.err.println("\n*** Optimization: run #" + z + " ***");
        }
        
        newData = data;
        finalRulesetStat = new RuleStats();
        finalRulesetStat.setData(newData);
        finalRulesetStat.setNumAllConds(m_Total);
        int position = 0;
        stop = false;
        boolean isResidual = false;
        hasPositive = defHasPositive;
        dl = minDL = defDL;
        

        while ((!stop) && (hasPositive))
        {
          isResidual = position >= ruleset.size();
          

          newData = RuleStats.stratify(newData, m_Folds, m_Random);
          Instances[] part = RuleStats.partition(newData, m_Folds);
          Instances growData = part[0];
          Instances pruneData = part[1];
          



          if (m_Debug) {
            System.err.println("\nRule #" + position + "| isResidual?" + isResidual + "| data size: " + newData.sumOfWeights());
          }
          
          RipperRule finalRule;
          if (isResidual) {
            RipperRule newRule = new RipperRule();
            newRule.setConsequent(classIndex);
            if (m_Debug) {
              System.err.println("\nGrowing and pruning a new rule ...");
            }
            newRule.grow(growData);
            newRule.prune(pruneData, false);
            RipperRule finalRule = newRule;
            if (m_Debug) {
              System.err.println("\nNew rule found: " + newRule.toString(m_Class));
            }
          }
          else {
            RipperRule oldRule = (RipperRule)ruleset.elementAt(position);
            boolean covers = false;
            
            for (int i = 0; i < newData.numInstances(); i++) {
              if (oldRule.covers(newData.instance(i))) {
                covers = true;
                break;
              }
            }
            if (!covers) {
              finalRulesetStat.addAndUpdate(oldRule);
              position++;
              continue;
            }
            

            if (m_Debug) {
              System.err.println("\nGrowing and pruning Replace ...");
            }
            RipperRule replace = new RipperRule();
            replace.setConsequent(classIndex);
            replace.grow(growData);
            





            pruneData = RuleStats.rmCoveredBySuccessives(pruneData, ruleset, position);
            replace.prune(pruneData, true);
            
            if (m_Debug) {
              System.err.println("\nGrowing and pruning Revision ...");
            }
            RipperRule revision = (RipperRule)oldRule.copy();
            

            Instances newGrowData = new Instances(growData, 0);
            for (int b = 0; b < growData.numInstances(); b++) {
              Instance inst = growData.instance(b);
              if (revision.covers(inst))
                newGrowData.add(inst);
            }
            revision.grow(newGrowData);
            revision.prune(pruneData, true);
            
            double[][] prevRuleStats = new double[position][6];
            for (int c = 0; c < position; c++) {
              prevRuleStats[c] = finalRulesetStat.getSimpleStats(c);
            }
            
            FastVector tempRules = (FastVector)ruleset.copyElements();
            tempRules.setElementAt(replace, position);
            
            RuleStats repStat = new RuleStats(data, tempRules);
            repStat.setNumAllConds(m_Total);
            repStat.countData(position, newData, prevRuleStats);
            
            double[] rst = repStat.getSimpleStats(position);
            if (m_Debug) {
              System.err.println("Replace rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
            }
            



            double repDL = repStat.relativeDL(position, expFPRate, m_CheckErr);
            
            if (m_Debug) {
              System.err.println("\nReplace: " + replace.toString(m_Class) + " |dl = " + repDL);
            }
            

            if ((Double.isNaN(repDL)) || (Double.isInfinite(repDL))) {
              throw new Exception("Should never happen: repDLin optmz. stage NaN or infinite!");
            }
            

            tempRules.setElementAt(revision, position);
            RuleStats revStat = new RuleStats(data, tempRules);
            revStat.setNumAllConds(m_Total);
            revStat.countData(position, newData, prevRuleStats);
            
            double revDL = revStat.relativeDL(position, expFPRate, m_CheckErr);
            

            if (m_Debug) {
              System.err.println("Revision: " + revision.toString(m_Class) + " |dl = " + revDL);
            }
            

            if ((Double.isNaN(revDL)) || (Double.isInfinite(revDL))) {
              throw new Exception("Should never happen: revDLin optmz. stage NaN or infinite!");
            }
            

            rstats = new RuleStats(data, ruleset);
            rstats.setNumAllConds(m_Total);
            rstats.countData(position, newData, prevRuleStats);
            
            double oldDL = rstats.relativeDL(position, expFPRate, m_CheckErr);
            

            if ((Double.isNaN(oldDL)) || (Double.isInfinite(oldDL))) {
              throw new Exception("Should never happen: oldDLin optmz. stage NaN or infinite!");
            }
            
            if (m_Debug) {
              System.err.println("Old rule: " + oldRule.toString(m_Class) + " |dl = " + oldDL);
            }
            

            if (m_Debug) {
              System.err.println("\nrepDL: " + repDL + "\nrevDL: " + revDL + "\noldDL: " + oldDL);
            }
            
            RipperRule finalRule;
            if ((oldDL <= revDL) && (oldDL <= repDL)) {
              finalRule = oldRule; } else { RipperRule finalRule;
              if (revDL <= repDL) {
                finalRule = revision;
              } else
                finalRule = replace;
            }
          }
          finalRulesetStat.addAndUpdate(finalRule);
          double[] rst = finalRulesetStat.getSimpleStats(position);
          
          if (isResidual)
          {
            dl += finalRulesetStat.relativeDL(position, expFPRate, m_CheckErr);
            

            if (m_Debug) {
              System.err.println("After optimization: the dl=" + dl + " | best: " + minDL);
            }
            
            if (dl < minDL) {
              minDL = dl;
            }
            stop = checkStop(rst, minDL, dl);
            if (!stop) {
              ruleset.addElement(finalRule);
            } else {
              finalRulesetStat.removeLast();
              position--;
            }
          }
          else {
            ruleset.setElementAt(finalRule, position);
          }
          if (m_Debug) {
            System.err.println("The rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
            



            System.err.println("\nRuleset so far: ");
            for (int x = 0; x < ruleset.size(); x++)
              System.err.println(x + ": " + ((RipperRule)ruleset.elementAt(x)).toString(m_Class));
            System.err.println();
          }
          

          if (finalRulesetStat.getRulesetSize() > 0)
            newData = finalRulesetStat.getFiltered(position)[1];
          hasPositive = Utils.gr(rst[5], 0.0D);
          position++;
        }
        
        if (ruleset.size() > position + 1) {
          for (int k = position + 1; k < ruleset.size(); k++)
            finalRulesetStat.addAndUpdate((Rule)ruleset.elementAt(k));
        }
        if (m_Debug) {
          System.err.println("\nDeleting rules to decrease DL of the whole ruleset ...");
        }
        finalRulesetStat.reduceDL(expFPRate, m_CheckErr);
        if (m_Debug) {
          int del = ruleset.size() - finalRulesetStat.getRulesetSize();
          
          System.err.println(del + " rules are deleted" + " after DL reduction procedure");
        }
        
        ruleset = finalRulesetStat.getRuleset();
        rstats = finalRulesetStat;
      }
    }
    


    if (m_Debug) {
      System.err.println("\nFinal ruleset: ");
      for (int x = 0; x < ruleset.size(); x++)
        System.err.println(x + ": " + ((RipperRule)ruleset.elementAt(x)).toString(m_Class));
      System.err.println();
    }
    
    m_Ruleset.appendElements(ruleset);
    m_RulesetStats.addElement(rstats);
    
    if (ruleset.size() > 0) {
      return rstats.getFiltered(ruleset.size() - 1)[1];
    }
    return data;
  }
  








  private boolean checkStop(double[] rst, double minDL, double dl)
  {
    if (dl > minDL + MAX_DL_SURPLUS) {
      if (m_Debug)
        System.err.println("DL too large: " + dl + " | " + minDL);
      return true;
    }
    if (!Utils.gr(rst[2], 0.0D)) {
      if (m_Debug)
        System.err.println("Too few positives.");
      return true;
    }
    if (rst[4] / rst[0] >= 0.5D) {
      if (m_CheckErr) {
        if (m_Debug) {
          System.err.println("Error too large: " + rst[4] + "/" + rst[0]);
        }
        return true;
      }
      
      return false;
    }
    
    if (m_Debug)
      System.err.println("Continue.");
    return false;
  }
  





  public String toString()
  {
    if (m_Ruleset == null) {
      return "JRIP: No model built yet.";
    }
    StringBuffer sb = new StringBuffer("JRIP rules:\n===========\n\n");
    
    for (int j = 0; j < m_RulesetStats.size(); j++) {
      RuleStats rs = (RuleStats)m_RulesetStats.elementAt(j);
      FastVector rules = rs.getRuleset();
      for (int k = 0; k < rules.size(); k++) {
        double[] simStats = rs.getSimpleStats(k);
        sb.append(((RipperRule)rules.elementAt(k)).toString(m_Class) + " (" + simStats[0] + "/" + simStats[4] + ")\n");
      }
    }
    
    if (m_Debug) {
      System.err.println("Inside m_Ruleset");
      for (int i = 0; i < m_Ruleset.size(); i++)
        System.err.println(((RipperRule)m_Ruleset.elementAt(i)).toString(m_Class));
    }
    sb.append("\nNumber of Rules : " + m_Ruleset.size() + "\n");
    
    return sb.toString();
  }
  




  public String getRevision()
  {
    return RevisionUtils.extract("$Revision: 8119 $");
  }
  




  public static void main(String[] args)
  {
    runClassifier(new JRip(), args);
  }
}
